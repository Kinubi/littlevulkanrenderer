#version 450
#define FLT_MAX 3.402823466e+38

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 viewMatrix;
    mat4 inverseViewMatrix;
    mat4 inverseProjectionMatrix;
    int sphereCount;
    int frameIndex;
};

struct Sphere {
    vec3 center;
    float radius;
    int materialIndex;
};

struct Material {
	vec3 albedo;
	vec3 emissiveColor;
	float emissiveStrength ;
	float roughness;
	float metalness;
	float refractiveIndex;
    int isTransparent;
};

layout(set=0, binding = 1) readonly buffer spheresBuffer {
    Sphere spheres[];
};

layout(set=0, binding = 2) readonly buffer materialBuffer {
    Material materials[];
};


layout(set=0, binding = 3, rgba32f) readonly uniform image2D imgInput;
layout(set=0, binding = 4, rgba32f) writeonly uniform image2D imgOutput;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float hitDistance;
    vec3 worldPosition;
    vec3 worldNormal;
    bool sphere;
    int itemIndex;
    bool frontFace;
};




layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Triangle {
    vec3 positions[3];
    int materialIndex;
};

Triangle triangle1 = Triangle(vec3[](
        vec3(-0.5, -1.0, 2.0),
        vec3(2.5, -1.0, 2.0),
        vec3(2.5,  2.0, 2.0)), 2);

Triangle triangle2 = Triangle(vec3[](
        vec3(2.5, 2.0, 2.0),
        vec3(-0.5,  2.0, 2.0),
        vec3(-0.5,-1.0, 2.0)), 2);

Triangle triangles[] = Triangle[](triangle1, triangle2);




Hit miss(Ray ray) {
    return Hit(-1.0, vec3(0), vec3(0), false, 0, false);
}

Hit closestHit(Ray ray, float hitDistance, int sphereIndex) {
    Hit payload;
    payload.hitDistance = hitDistance;
    payload.sphere = true;
    payload.itemIndex = sphereIndex;

    Sphere closestSphere = spheres[sphereIndex];

    payload.worldPosition = ray.origin  + ray.direction * hitDistance;
    payload.worldNormal = normalize(payload.worldPosition - closestSphere.center);
    payload.frontFace = dot(ray.direction, payload.worldNormal) < 0.0;

    return payload;
}

Hit checkSpheres(Ray ray, inout float hitDistance) {
    int closestSphere = -1;
    for (int i = 0; i < sphereCount; i++) {
        Sphere sphere = spheres[i];
        vec3 oc = ray.origin - sphere.center;
        float a = dot(ray.direction, ray.direction);
        float b = 2.0 * dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius * sphere.radius;
        float discriminant = b * b - 4.0 * a * c;

        if (discriminant < 0.0) {
            continue;
        }

        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
        float t = (t0 < t1) ? t0 : t1;
        //float t = t0;

        if (t < hitDistance && t >= 0.0) {
            hitDistance = t;
            closestSphere = i;
            }
    }

    if (closestSphere < 0) {
        return miss(ray);
    
    }

    return closestHit(ray, hitDistance, closestSphere);
        
}



Hit checkTriangles(Ray ray, float hitDistance) {
    int closestTriangle = -1;
    for (int i = 0; i < triangles.length(); i++) {
        Triangle triangle = triangles[i];
        vec3 v0v1 = triangle.positions[1] - triangle.positions[0];
        vec3 v0v2 = triangle.positions[2] - triangle.positions[0];
        vec3 pvec = cross(ray.direction, v0v2);
        float det = dot(v0v1, pvec);

        if (abs(det) < 1e-8) continue;

        float invDet = 1.0 / det;
        vec3 tvec = ray.origin - triangle.positions[0];
        float u = dot(tvec, pvec) * invDet;
        if (u < 0.0 || u > 1.0) continue;

        vec3 qvec = cross(tvec, v0v1);
        float v = dot(ray.direction, qvec) * invDet;
        if (v < 0.0 || u + v > 1.0) continue;

        float t = dot(v0v2, qvec) * invDet;
        if (t < hitDistance && t >= 0.0) {
            hitDistance = t;
            closestTriangle = i;
        }
    }

    if (closestTriangle < 0) {
        return miss(ray);
    }

    Hit payload;
    payload.hitDistance = hitDistance;
    payload.sphere = false;
    payload.itemIndex = closestTriangle;

    Triangle closestTri = triangles[closestTriangle];
    vec3 v0v1 = closestTri.positions[1] - closestTri.positions[0];
    vec3 v0v2 = closestTri.positions[2] - closestTri.positions[0];
    vec3 normal = normalize(cross(v0v1, v0v2));

    payload.worldPosition = ray.origin + ray.direction * hitDistance;
    payload.worldNormal = normal;
    payload.frontFace = dot(ray.direction, normal) < 0.0;


    return payload;
    
}


Hit traceRay(Ray ray) {
    
    float hitDistance = FLT_MAX;
    Hit hitSphere = checkSpheres(ray, hitDistance);
    if (hitSphere.hitDistance < 0.0) {
        hitDistance = FLT_MAX;
    }
    Hit hitTriangle = checkTriangles(ray, hitDistance);
    if (hitTriangle.hitDistance < 0.0) {
        return hitSphere;
    } else {
        return hitTriangle;
    }

}

uint PCG_Hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float RandomFloat(inout uint seed) {
    seed = PCG_Hash(seed);
    return float(seed)/4294967295.0;
}

float RandomValueNormalDistribution(inout uint seed) {
    // Thanks to https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * RandomFloat(seed);
    float rho = sqrt(-2 * log(RandomFloat(seed)));
    return rho * cos(theta);
}

vec3 InUnitSphere(inout uint seed) {
    return normalize(vec3(
            RandomFloat(seed) * 2.0f - 1.0f, 
            RandomFloat(seed) * 2.0f - 1.0f, 
            RandomFloat(seed) * 2.0f - 1.0f));
}

vec3 calculateSkyColor(vec3 direction) {
    
    float t = 0.5 * (direction.y + 1.0);
    vec3 skyColor = mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t);
    vec3 groundColor = vec3(0.8, 0.8, 0.8);
    return mix(groundColor, skyColor, smoothstep(-1.0, 1.0, direction.y));
    
}

float schlick(float cosine, float refraction_index) {
        // Use Schlick's approximation for reflectance.
        float r0 = (1 - refraction_index) / (1 + refraction_index);
        r0 = r0*r0;
        return r0 + (1-r0)*pow((1 - cosine),5);
    }

vec4 calculateLightContribution(Ray ray, inout uint seed) {
    // Initialize the contribution and light variables
    vec3 contribution = vec3(1.0);
    vec4 light = vec4(0.0);
    Ray outGoingRay = ray;

    int numBounces = 10;

    // Loop through the number of bounces
    for (int bounce = 0; bounce < numBounces; bounce++) {
        seed += bounce;
        Hit hit = traceRay(outGoingRay);
        
        
        // If no hit, add sky color and break
        if (hit.hitDistance < 0.0f) {
            vec3 skyColor = calculateSkyColor(outGoingRay.direction);
            light += vec4(contribution, 1.0f) * vec4(skyColor, 1.0);
            break;
        }
        
        // Update the outgoing ray
        
        int materialIndex = hit.sphere ? spheres[hit.itemIndex].materialIndex : triangles[hit.itemIndex].materialIndex;
        float isSpecular = materials[materialIndex].metalness >= RandomFloat(seed) ? 1.0 : 0.0;
        outGoingRay.origin = hit.worldPosition;
        if (materials[materialIndex].isTransparent > 0) {
            float ri = hit.frontFace ? 1.0 / materials[materialIndex].refractiveIndex : materials[materialIndex].refractiveIndex;
            float cosTheta = min(dot(-outGoingRay.direction, hit.worldNormal), 1.0);
            float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
            bool cannotRefract = ri * sinTheta > 1.0;
            if (cannotRefract || schlick(cosTheta, ri) > RandomFloat(seed))
                outGoingRay.direction = reflect(outGoingRay.direction, hit.worldNormal);
            else
                outGoingRay.direction = refract(outGoingRay.direction, hit.worldNormal, ri);
        } else {

            vec3 diffuseDir = normalize(hit.worldNormal + InUnitSphere(seed));
            vec3 specularDir = reflect(ray.direction, hit.worldNormal);
            outGoingRay.direction = normalize(mix(diffuseDir, specularDir, isSpecular * (1.0 - materials[materialIndex].roughness)));
        }

        // Calculate light contribution from the hit

        light += vec4(materials[materialIndex].emissiveStrength * materials[materialIndex].emissiveColor * contribution, 1.0);
        contribution *= mix(materials[materialIndex].albedo, vec3(1.0), isSpecular);
        

    }

    return light;
}


vec3 sample_square(inout uint seed) {
    // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
    return vec3(RandomFloat(seed) - 0.5, RandomFloat(seed) - 0.5, 0);
}


// Function to initialize the ray
Ray initializeRay(ivec2 pixelCoord, vec2 resolution, inout uint seed) {
    Ray ray;
    vec2 pixelCoordfloat = vec2(pixelCoord) + sample_square(seed).xy;
    vec2 uv = (pixelCoordfloat / resolution) * 2.0 - 1.0;

    vec4 clipSpacePos = vec4(uv, -1.0, 1.0);
    vec4 viewSpacePos = inverseProjectionMatrix * clipSpacePos;
    viewSpacePos /= viewSpacePos.w;
    vec4 worldSpacePos = inverseViewMatrix * viewSpacePos;


    ray.origin = vec3(inverseViewMatrix[3]);
    ray.direction = normalize(worldSpacePos.xyz - ray.origin);

    return ray;
}

// Function to compute the final color
vec4 computeFinalColor(ivec2 pixelCoord, vec2 resolution, uint seed, int numRays) {
    Ray ray = initializeRay(pixelCoord, resolution, seed);
    vec4 total_color = vec4(0.0);
    for (int rayNum = 0; rayNum < numRays; rayNum++) {
        seed += rayNum;
        total_color += calculateLightContribution(ray, seed);
    }
    return total_color / float(numRays);
}

// Main function
void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 resolution = vec2(imageSize(imgOutput));
    uint seed = uint(pixelCoord.x + resolution.y) * uint(pixelCoord.y + resolution.x);



    int numRays = 50;
    seed *= frameIndex;

    vec4 total_color = computeFinalColor(pixelCoord, resolution, seed, numRays);

    vec4 sampledColor = imageLoad(imgInput, pixelCoord);

    if (frameIndex == 0) {
        imageStore(imgOutput, pixelCoord, total_color);
    } else {
        float weight = 1.0 / float(frameIndex);
        vec4 new_color = clamp(sampledColor * (1.0 - weight) + total_color * weight, 0.0, 1.0);
        imageStore(imgOutput, pixelCoord, new_color);
    }
}