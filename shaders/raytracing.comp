#version 450
#define FLT_MAX 3.402823466e+38

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 viewMatrix;
    mat4 inverseViewMatrix;
    mat4 inverseProjectionMatrix;
    int sphereCount;
    int frameIndex;
};

struct Sphere {
    vec3 center;
    vec3 color;
    float radius;
};

layout(set=0, binding = 1) readonly buffer SpheresSSBOIn {
    Sphere spheresIn[];
};

layout(set=0, binding = 2, rgba32f) readonly uniform image2D imgInput;
layout(set=0, binding = 3, rgba32f) writeonly uniform image2D imgOutput;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float hitDistance;
    vec3 worldPosition;
    vec3 worldNormal;
    int sphereIndex;
};

vec3 emissionPower = vec3(25.0, 0.0, 0.0);
const float SPHERE_JITTER_FACTOR = 0.01;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

Hit miss(Ray ray) {
    return Hit(-1.0, vec3(0), vec3(0), 0);
}

Hit closestHit(Ray ray, float hitDistance, int sphereIndex) {
    Hit payload;
    payload.hitDistance = hitDistance;
    payload.sphereIndex = sphereIndex;

    Sphere closestSphere = spheresIn[sphereIndex];

    payload.worldPosition = ray.origin + ray.direction * hitDistance;
    payload.worldNormal = normalize(payload.worldPosition - closestSphere.center);

    return payload;
}

Hit traceRay(Ray ray) {
    int closestSphere = -1;
    float hitDistance = 10000000.0;
    for (int i = 0; i < sphereCount; i++) {
        Sphere sphere = spheresIn[i];
        vec3 oc = ray.origin - sphere.center;
        float a = dot(ray.direction, ray.direction);
        float b = 2.0 * dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius * sphere.radius;
        float discriminant = b * b - 4.0 * a * c;
        if (discriminant < 0.0) {
            continue;
        } else {
            float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
            float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
            float t = (t0 < (t1 + 0.0001) && t0 > 0.0001) ? t0 : t1; 
            if (t < hitDistance) {
                hitDistance = t;
                closestSphere = i;
            }
        }
    }
    if (closestSphere < 0) {
        return miss(ray);
    }
    return closestHit(ray, hitDistance, closestSphere);
}

uint PCG_Hash(uint seed) {
    uint state = seed * 747796405 + 2891336453;
    uint word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    return (word >> 22) ^ word;
}

uint lcg(inout uint seed) {
    uint LCG_A = 1664525;
    uint LCG_C = 1013904223;
    seed       = (LCG_A * seed + LCG_C);
    return seed & 0x00FFFFFF;
}

float RandomFloat(inout uint seed) {
    seed = PCG_Hash(seed);
    return float(seed)/4294967295.0;
}



float RandomValueNormalDistribution(inout uint seed) {
    // Thanks to https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * RandomFloat(seed);
    float rho = sqrt(-2 * log(1-RandomFloat(seed)));
    return rho * cos(theta);
}

float hash11(inout float p) {
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}


vec3 InUnitSphere(inout uint seed) {
    return normalize(vec3(
            RandomFloat(seed) *2.0 - 1.0, 
            RandomFloat(seed)*2.0 - 1.0, 
            RandomFloat(seed)*2.0 - 1.0));
}

vec3 calculateSkyColor(vec3 direction) {
    return vec3(0.3f, 0.35f, 0.45f);
}

vec4 calculateLightContribution(Ray ray, uint seed) {
    vec3 contribution = vec3(1.0);
    vec4 light = vec4(0.0);

    int numBounces = 10;

    for (int bounce = 0; bounce < numBounces; bounce++) {

        Hit hit = traceRay(ray);
        float isSpecular = RandomFloat(seed) < 0.5 ? 1.0 : 0.0;
        if (hit.hitDistance < 0.0f) {
            vec3 skyColor = calculateSkyColor(ray.direction);
            light += vec4(contribution, 1.0) * vec4(skyColor, 1.0);
            break;
        }
        Sphere sphere = spheresIn[hit.sphereIndex];
        light += vec4(emissionPower[hit.sphereIndex] * sphere.color * contribution, 1.0);
        contribution *= sphere.color;
        ray.origin = hit.worldPosition;
        vec3 diffuseDir = normalize(hit.worldNormal + InUnitSphere(seed));
        vec3 specularDir = reflect(ray.direction, hit.worldNormal);
        ray.direction = normalize(mix(diffuseDir, specularDir, isSpecular));
    }

    return light;
}


void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 resolution = vec2(imageSize(imgOutput));
    uint seed = uint(pixelCoord.x/resolution.x + uint(pixelCoord.y/resolution.y * resolution.x));

    Ray ray;
    vec2 uv = (pixelCoord / resolution) * 2.0 - 1.0;

    ray.origin = inverseViewMatrix[3].xyz;
    vec4 target = inverseProjectionMatrix * vec4(uv, 1.0, 1.0);
    ray.direction = normalize((inverseViewMatrix * target)).xyz;

    int numRays = 500;
    vec4 total_color = vec4(0.0);

    

    seed *= frameIndex;

    for (int rayNum = 0; rayNum < numRays; rayNum++) {

        total_color += calculateLightContribution(ray, seed);
    }
    total_color /= numRays;

    vec4 sampledColor = imageLoad(imgInput, pixelCoord);

    total_color = vec4(pow(total_color.rgb, vec3(1.0 / 2.2)), total_color.a);
    if (frameIndex > 1) {
        float weight = float(1.0 / float(frameIndex + 1));
        vec4 new_color = sampledColor * (1 - weight) + total_color * weight;
        imageStore(imgOutput, pixelCoord, new_color);
        
    } else {
        imageStore(imgOutput, pixelCoord, total_color);
    }

}
