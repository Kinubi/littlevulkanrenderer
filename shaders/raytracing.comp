#version 450

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 viewMatrix;
    mat4 inverseViewMatrix;
    mat4 inverseProjectionMatrix;
    int sphereCount;
    int frameIndex;
};

struct Sphere {
    vec3 center;
    vec3 color;
    float radius;
};

layout(set=0, binding = 1) readonly buffer SpheresSSBOIn {
    Sphere spheresIn[];
};

layout(set=0, binding = 2, rgba32f) readonly uniform image2D imgInput;
layout(set=0, binding = 3, rgba32f) writeonly uniform image2D imgOutput;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float hitDistance;
    vec3 worldPosition;
    vec3 worldNormal;
    int sphereIndex;
};

vec4 emissionPower = vec4(50.0, 0.0, 0.0, 0.0);
const float SPHERE_JITTER_FACTOR = 0.01;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

Hit miss(Ray ray) {
    return Hit(-1.0, vec3(0), vec3(0), 0);
}

Hit closestHit(Ray ray, float hitDistance, int sphereIndex) {
    Hit payload;
    payload.hitDistance = hitDistance;
    payload.sphereIndex = sphereIndex;

    Sphere closestSphere = spheresIn[sphereIndex];

    payload.worldPosition = ray.origin  + ray.direction * hitDistance;
    payload.worldNormal = normalize(payload.worldPosition - closestSphere.center);

    return payload;
}

Hit traceRay(Ray ray) {
    int closestSphere = -1;
    float hitDistance = 10000000.0;
    for (int i = 0; i < sphereCount; i++) {
        Sphere sphere = spheresIn[i];
        vec3 oc = ray.origin - sphere.center;
        float a = dot(ray.direction, ray.direction);
        float b = 2.0 * dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius * sphere.radius;
        float discriminant = b * b - 4.0 * a * c;
        if (discriminant < 0.0) {
            continue;
        } else {
            float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
            float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
            float t = (t0 < t1 && t0 > 0.0) ? t0 : t1; 
            if (t < hitDistance) {
                hitDistance = t;
                closestSphere = i;
            }
        }
    }
    if (closestSphere < 0) {
        return miss(ray);
    }
    return closestHit(ray, hitDistance, closestSphere);
}

uint PCG_Hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float RandomFloat(out uint seed) {
    seed = PCG_Hash(seed);
    return float(seed)/pow(2, 64);
}

vec3 InUnitSphere(out uint seed) {
    return normalize(vec3(
            RandomFloat(seed) * 2.0f - 1.0f, 
            RandomFloat(seed) * 2.0f - 1.0f, 
            RandomFloat(seed) * 2.0f - 1.0f));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 resolution = vec2(imageSize(imgOutput));
    uint seed = uint(pixelCoord.x + pixelCoord.y) * uint(resolution.x);

    Ray ray;
    vec2 uv = (pixelCoord / resolution) * 2.0 - 1.0;

    vec4 clipSpacePos = vec4(uv, -1.0, 1.0);
    vec4 viewSpacePos = inverseProjectionMatrix * clipSpacePos;
    viewSpacePos /= viewSpacePos.w;
    vec4 worldSpacePos = inverseViewMatrix * viewSpacePos;

    ray.origin = vec3(inverseViewMatrix[3]);

    ray.direction = normalize(worldSpacePos.xyz - ray.origin);

    int numRays = 100;

    vec4 total_color = vec4(0.0);
    int numBounces = 10;
    float t;

    seed *= frameIndex;

    for (int rayNum = 0; rayNum < numRays; rayNum++) {
        vec3 contribution = vec3(1.0);
        vec4 light = vec4(0.0);
        Ray outGoingRay = ray;

        for (int bounce = 0; bounce < numBounces; bounce++) {
            seed += bounce;
            Hit hit = traceRay(outGoingRay);
            float isSpecular = RandomFloat(seed);
            if (hit.hitDistance < 0.0f) {
                vec3 skycolor = vec3(0.3, 0.5, 0.4);
                light += vec4(contribution, 1.0f) * vec4(skycolor.xyz, 1.0);

                break;
            }
            Sphere sphere = spheresIn[hit.sphereIndex];
            contribution *= sphere.color;
            light += vec4(contribution * emissionPower[hit.sphereIndex] * sphere.color, 1.0);
            outGoingRay.origin = hit.worldPosition + hit.worldNormal;
            vec3 diffuseDir = normalize(hit.worldNormal + InUnitSphere(seed));
            vec3 specularDir = reflect(ray.direction, hit.worldNormal);
            outGoingRay.direction = normalize(mix(diffuseDir, specularDir, isSpecular));
        }

        total_color += light;
    }
    total_color /= numRays;

    //vec2 textureUv = pixelCoord/ vec2(textureSize(imgInput, 0));
    //vec4 sampledColor = texture(imgInput, textureUv);
    vec4 sampledColor = imageLoad(imgInput, pixelCoord);

    if (frameIndex == 0) {
        imageStore(imgOutput, pixelCoord, total_color);
    } else {
        float weight = 1.0 / (frameIndex);

        vec4 new_color = sampledColor * (1-weight) + total_color * weight;
        imageStore(imgOutput, pixelCoord, new_color);
    }
}
