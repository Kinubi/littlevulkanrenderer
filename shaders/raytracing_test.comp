#version 450

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 viewMatrix;
    mat4 inverseViewMatrix;
    mat4 inverseProjectionMatrix;
    int sphereCount;
    int frameIndex;
};

struct Sphere {
    vec3 center;
    vec3 color;
    float radius;
    int MaterialIndex = 0;
};

layout(set=0, binding = 1) readonly buffer SpheresSSBOIn {
    Sphere spheresIn[];
};

layout(set=0, binding = 2) uniform sampler2D imgInput;
layout(set=0, binding = 3, rgba32f) writeonly uniform image2D imgOutput;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitPayload {
    float hitDistance;
    vec3 worldSpacePosition;
    vec3 worldNormal;
    int sphereIndex;
};

struct Material {
    vec3 Albedo(1.0);
    float Roughness = 1.0f;
    float Metallic = 0.0f;
    vec3 EmissionColor(0.0);
    float EmissionPower = 0.0f;
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

Hit intersectSphere(Ray ray, Sphere sphere, out float t) {
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4.0 * a * c;
    if (discriminant < 0.0) {
        return Hit(0.0, vec3(0.0), vec3(0.0), vec3(0.0));
    } else {
        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
        t = (t0 < t1 && t0 > 0.0) ? t0 : t1;
        return Hit(t, ray.origin - sphere.center, normalize(ray.origin + t * ray.direction - sphere.center), sphere.color);
    }
}

float random(uint seed) {
    seed = seed * 747796405u + 2891336453u;
    uint result = ((seed >> ((seed >> 28) + 4U)) ^ seed) * 277803737u;
    result = (result >> 22) ^ result;
    return float(result) / 4294967295.0;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 resolution = vec2(imageSize(imgOutput));

    Ray ray;
    vec2 uv = (pixelCoord / resolution) * 2.0 - 1.0;
    vec4 clipSpacePos = vec4(uv, -1.0, 1.0);
    vec4 viewSpacePos = inverseProjectionMatrix * clipSpacePos;
    viewSpacePos /= viewSpacePos.w;
    vec4 worldSpacePos = inverseViewMatrix * viewSpacePos;

    ray.origin = vec3(inverseViewMatrix[3]);
    ray.direction = normalize(worldSpacePos.xyz - ray.origin);

    int numRays = 50;
    vec4 color = vec4(0.0);
    int numBounces = 5;
    float t;
    uint seed = floatBitsToUint(texture(imgInput, pixelCoord).x/ray.direction.y + texture(imgInput, pixelCoord).y/ray.direction.x);
    for (int rayNum=0; rayNum < numRays; rayNum++) {
        Ray raySent = ray;
        //raySent.direction *= 0.001 * vec3(random(seed), random(seed), random(seed));
        for (int bounce = 0; bounce < numBounces; bounce++) {
            float closestSphere = 1000000000.0;
            Hit closestHit;
            for (int i = 0; i < sphereCount; i++) {
                Hit hit = intersectSphere(raySent, spheresIn[i], t);
                if (hit.t < closestSphere && hit.t > 0.0) {
                    closestSphere = hit.t;
                    closestHit = hit;
                }
                if (closestSphere < 1000000000.0) {
                    color += vec4(closestHit.color, 1.0);// * dot(closestHit.normal, -ray.direction);
                    raySent.origin = hit.worldSpacePosition + (hit.normal * 0.0001);
                    //worldSpacePosition = raySent.origin + closestSphere * raySent.direction;
                    //raySent.direction = reflect(raySent.direction, closestHit.normal + vec3(random(seed), random(seed), random(seed)));
                    raySent.direction = normalize(hit.worldSpacePosition + vec3(random(seed),random(seed), random(seed)));
                } else {
                    color *=vec4(0.6f, 0.7f, 0.9f, 1.0);
                    break;
                }
            }
        }
    }

    vec4 sampledColor = texture(imgInput, vec2(pixelCoord) / resolution);
    if (sampledColor.w >= 1 && frameIndex > 0) {
        imageStore(imgOutput, pixelCoord, (color + texture(imgInput, pixelCoord))/(frameIndex));
    } else {
        imageStore(imgOutput, pixelCoord, color)
        ;
    }
}